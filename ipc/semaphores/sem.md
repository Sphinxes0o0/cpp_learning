# POSIX 信号量 (Semaphores)

## 目录
- [工作原理](#工作原理)
- [信号量类型](#信号量类型)
- [主要函数](#主要函数)
- [生产-消费者问题](#生产-消费者问题)
- [进程与线程的比较](#进程与线程的比较)
- [平台兼容性](#平台兼容性)
- [使用建议](#使用建议)

## 工作原理
信号量本质上是一个由内核管理的、受保护的整数计数器。进程可以对它进行两种原子操作（不可中断的操作）：

1. sem_wait() (等待):

- 尝试将信号量计数减 1。

- 如果计数器当前大于 0，则减 1 成功，函数立即返回。

- 如果计数器当前等于 0，则进程会阻塞（进入睡眠状态），直到有其他进程对该信号量执行 sem_post() 操作。

2. sem_post() (发布):

- 将信号量计数加 1。

- 如果此时有其他进程因为 sem_wait() 而被阻塞在该信号量上，内核会唤醒其中一个进程。

通过控制这个计数器的初始值和增减时机，就能实现复杂的同步逻辑。

## 信号量类型

POSIX 信号量分为两种类型：

1. **命名信号量 (Named Semaphores)**
   - 通过名称在进程间共享
   - 使用 `sem_open()` 创建和打开
   - 可以被不相关的进程使用
   - 需要显式删除 (`sem_unlink()`)

2. **无名信号量 (Unnamed Semaphores)**
   - 仅在进程内或通过共享内存共享
   - 使用 `sem_init()` 初始化
   - 通常用于线程间同步
   - 使用完后需要调用 `sem_destroy()` 销毁

## 主要函数

### 命名信号量函数

```c
#include <semaphore.h>

// 创建或打开一个命名信号量
sem_t *sem_open(const char *name, int oflag, ...);

// 关闭信号量（与文件描述符类似）
int sem_close(sem_t *sem);

// 删除信号量的名字（标记为待删除）
int sem_unlink(const char *name);

// 等待（减1操作）
int sem_wait(sem_t *sem);

// 尝试等待（非阻塞）
int sem_trywait(sem_t *sem);

// 发送信号（加1操作）
int sem_post(sem_t *sem);

// 获取信号量当前值
int sem_getvalue(sem_t *sem, int *sval);
```

### 无名信号量函数

```c
#include <semaphore.h>

// 初始化无名信号量
int sem_init(sem_t *sem, int pshared, unsigned int value);

// 销毁无名信号量
int sem_destroy(sem_t *sem);
```

## 生产-消费者问题

要实现一个安全的多生产者-多消费者模型，需要在共享内存的基础上，引入三种不同角色的信号量：

1. 一个互斥锁 (Mutex):

- 这是一个特殊的、初始值为 1 的信号量。

- 作用：
    确保任何时候只有一个进程（无论是生产者还是消费者）可以访问共享缓冲区。这解决了数据竞争问题。

- 逻辑：
    在访问缓冲区前 sem_wait()，访问结束后 sem_post()。

2. 一个"空槽位"计数器 (empty_slots):

- 初始值为共享缓冲区的大小（比如 N）。

- 作用:
    记录缓冲区中还有多少个空位可以放产品。

- 逻辑：
    生产者在生产前必须先 sem_wait() 这个信号量。如果值为 0（缓冲区满了），生产者就会自动阻塞，直到有消费者取走产品。

3. 一个"产品数"计数器 (full_slots):

- 初始值为 0。

- 作用：
    记录缓冲区中已经有多少个产品可以被消费。

- 逻辑：
    消费者在消费前必须先 sem_wait() 这个信号量。如果值为 0（缓冲区是空的），消费者就会自动阻塞，直到有生产者放入产品。

这个"一个锁，两个计数器"的设计是解决生产者-消费者问题的经典范式。

### 实现要点

1. **信号量操作顺序**：生产者必须先检查空位（empty）再获取锁（mutex），否则可能导致死锁
2. **错误处理**：所有信号量和共享内存操作都需要检查返回值
3. **资源清理**：使用完毕后必须清理所有 IPC 资源

## 进程与线程的比较

在实现生产者-消费者模型时，可以选择使用进程或线程：

### 进程版本
- 使用命名信号量进行同步
- 每个进程有独立的地址空间
- 数据共享通过共享内存实现
- 进程间通信开销较大
- 适合需要高隔离性的场景

### 线程版本
- 使用无名信号量进行同步（在支持的平台上）
- 所有线程共享同一地址空间
- 数据共享直接通过全局变量实现
- 线程间通信开销较小
- 适合需要高并发且数据共享频繁的场景

## 平台兼容性

不同操作系统对 POSIX 信号量的支持可能有所不同：

1. **Linux**: 完整支持 POSIX 无名信号量
2. **macOS**: 对 POSIX 无名信号量的支持有限，推荐使用 GCD (Grand Central Dispatch) 信号量
3. **Windows**: 需要使用 Windows API 或第三方库

在 macOS 上，可以使用 `dispatch_semaphore` 作为替代方案：

```c
#include <dispatch/dispatch.h>

// 创建信号量
dispatch_semaphore_t sem = dispatch_semaphore_create(value);

// 等待信号量
dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);

// 释放信号量
dispatch_semaphore_signal(sem);
```

## 使用建议

1. **命名规范**：信号量名称应以 "/" 开头，在系统中唯一
2. **错误检查**：始终检查系统调用的返回值
3. **资源管理**：确保所有进程都调用 sem_close()，且至少一个进程调用 sem_unlink()
4. **死锁预防**：多个信号量操作时，所有进程应按相同顺序获取信号量
5. **性能考虑**：频繁的 sem_wait()/sem_post() 操作可能成为性能瓶颈
6. **平台兼容性**：在跨平台项目中，考虑使用条件编译或平台特定的实现